{"version":3,"sources":["webpack:///../docs/guides/structured-and-sequence-selectors.md"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"weAMO,IAAMA,EAAe,Q,kOAE5B,IAKMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,E,oIACF,mBACD,OAAO,YAACJ,EAAD,KAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,iBAAQ,CACN,GAAM,kCADR,mCAGA,yCAAwB,mBAAGC,WAAW,KAAQ,CAC1C,KAAQ,wCADY,YAAxB,+BAEqD,mBAAGA,WAAW,KAAQ,CACvE,KAAQ,+GADyC,uBAFrD,kGAImI,0BAAYA,WAAW,KAAvB,uBAJnI,sIAKA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,qSAcL,2FACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,mMASL,+DACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,+JASL,oEAAmD,mBAAGA,WAAW,KAAQ,CACrE,KAAQ,iDADuC,eAAnD,6BAEsD,0BAAYA,WAAW,KAAvB,8BAFtD,6DAGA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,uhBAoBL,mEACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,kPASL,kHAAiG,0BAAYA,WAAW,KAAvB,qBAAjG,qBACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,kmBAqBL,kFACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,mUAmBL,4GACA,uBAAK,sBAAMA,WAAW,OAAU,CAC5B,UAAa,wBADZ,y/B,yNAwCTJ,EAAWK,gBAAiB","file":"component---docs-guides-structured-and-sequence-selectors-md-7e542282a5d53923b684.js","sourcesContent":["import React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsx mdx */\n\nimport DefaultLayout from \"/home/sergey/IdeaProjects/reselect-utils/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\n\nconst makeShortcode = name => function MDXDefaultShortcode(props) {\n  console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n  return <div {...props} />;\n};\n\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"structured--sequence-selectors\"\n    }}>{`Structured & Sequence Selectors`}</h1>\n    <p>{`If you ever used `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/reduxjs/reselect\"\n      }}>{`Reselect`}</a>{`, you must be familiar with `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/reduxjs/reselect#createstructuredselectorinputselectors-selectorcreator--createselector\"\n      }}>{`Structured Selector`}</a>{`. Reselect Utils provides implementation of this helper but with improved typings. You can use `}<inlineCode parentName=\"p\">{`Structured Selector`}</inlineCode>{` from this library with heterogeneous selectors. Heterogeneous selectors are selectors with different types of state. See example:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`type PersonsStateSlice = {\n  persons: Record<number, Person>;\n};\n\nconst personsSelector = (state: PersonsStateSlice) => state.persons;\n\ntype MessagesStateSlice = {\n  messages: Record<number, Message>;\n};\n\nconst messagesSelector = (state: MessagesStateSlice) => state.messages;\n`}</code></pre>\n    <p>{`Now we can write selector what select data from both state slices:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { createStructuredSelector } from 'reselect-utils';\n\nconst personsAndMessagesSelector = createStructuredSelector({\n  persons: personsSelector,\n  messages: messagesSelector,\n});\n`}</code></pre>\n    <p>{`You can also use alias to reduce code:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { struct } from 'reselect-utils';\n\nconst personsAndMessagesSelector = struct({\n  persons: personsSelector,\n  messages: messagesSelector,\n});\n`}</code></pre>\n    <p>{`If you use parametric selector, you can use `}<a parentName=\"p\" {...{\n        \"href\": \"https://github.com/toomuchdesign/re-reselect\"\n      }}>{`Re-reselect`}</a>{`. Reselect Utils provides `}<inlineCode parentName=\"p\">{`Cached Structured Selector`}</inlineCode>{` for these proposes. For example, we have next selectors:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import createCachedSelector from 're-reselect';\n\nconst personSelector = createCachedSelector(\n  personsSelector,\n  (state: PersonsStateSlice, props: Props) => props.personId,\n  (persons, personId) => persons[personId],\n)({\n  keySelector: (state, props) => props.personId,\n});\n\nconst messageSelector = createCachedSelector(\n  messagesSelector,\n  (state: MessagesStateSlice, props: Props) => props.messageId,\n  (messages, messageId) => messages[messageId],\n)({\n  keySelector: (state, props) => props.messageId,\n});\n`}</code></pre>\n    <p>{`You can write composing selector this way:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { cachedStruct } from 'reselect-utils';\n\nconst personAndMessageSelector = cachedStruct({\n  persons: personSelector,\n  messages: messageSelector,\n})({ keySelector: (state, props) => \\`\\${props.personId}:\\${props.messageId}\\` });\n`}</code></pre>\n    <p>{`There is also another type of structure besides objects - arrays. Reselect Utils provides `}<inlineCode parentName=\"p\">{`Sequence Selector`}</inlineCode>{` helper for them:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import createCachedSelector from 're-reselect';\nimport { bound, createSequenceSelector } from 'reselect-utils';\n\nconst personSelector = createCachedSelector(\n  personsSelector,\n  (state: PersonsStateSlice, props: Props) => props.personId,\n  (persons, personId) => persons[personId],\n)({\n  keySelector: (state, props) => props.personId,\n});\n\nconst firstPersonSelector = bound(personSelector, { personId: 1 });\nconst secondPersonSelector = bound(personSelector, { personId: 2 });\n\nconst firstTwoPersonsSelector = createSequenceSelector([\n  firstPersonSelector,\n  secondPersonSelector,\n]);\n`}</code></pre>\n    <p>{`Now if you have next state, you will receive next result:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`const state = {\n  persons: {\n    1: {\n      id: 1,\n      firstName: 'Marry',\n      secondName: 'Poppins',\n    },\n    2: {\n      id: 2,\n      firstName: 'Harry',\n      secondName: 'Potter',\n    },\n  },\n};\n\nfirstTwoPersonsSelector(state); // => [{ firstName: 'Marry', ... }, { firstName: 'Harry', ... }]\n`}</code></pre>\n    <p>{`If you try to combine parametric selectors, there is cached version of this helper:`}</p>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-typescript\"\n      }}>{`import { path, prop, bound, cachedSeq } from 'reselect-utils';\n\ntype Props = {\n  personId: number;\n  postfix: string;\n};\n\nconst personFullNameSelector = createCachedSelector(\n  path(personSelector).firstName(),\n  path(personSelector).secondName(),\n  prop<Props>().postfix(),\n  (firstName, secondName, postfix) => \\`\\${firstName} \\${secondName} (\\${postfix})\\`,\n)({\n  keySelector: (state, props) => \\`\\${props.personId}:\\${props.postfix}\\`,\n});\n\nconst firstPersonFullNameSelector = bound(personFullNameSelector, {\n  personId: 1,\n});\nconst secondPersonFullNameSelector = bound(personFullNameSelector, {\n  personId: 2,\n});\n\nconst firstTwoPersonFullNamesSelector = cachedSeq([\n  firstPersonFullNameSelector,\n  secondPersonFullNameSelector,\n])({\n  keySelector: prop<Props>().postfix(),\n});\n\nfirstTwoPersonsSelector(state, { postfix: '*' }); // => ['Marry Poppins (*)', 'Harry Potter (*)' }]\n\nfirstTwoPersonsSelector(state, { postfix: '?' }); // => ['Marry Poppins (?)', 'Harry Potter (?)' }]\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}