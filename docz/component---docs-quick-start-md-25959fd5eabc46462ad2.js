(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{HhXU:function(e,t,n){"use strict";n.r(t),n.d(t,"_frontmatter",(function(){return o})),n.d(t,"default",(function(){return p}));n("1c7q"),n("abGl"),n("gZHo"),n("Fdmb"),n("Ir+3"),n("2mQt"),n("mXGw");var a=n("/FXl"),r=n("TjRS");n("aD51");function s(){return(s=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}var o={};void 0!==o&&o&&o===Object(o)&&Object.isExtensible(o)&&!o.hasOwnProperty("__filemeta")&&Object.defineProperty(o,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"docs/quick-start.md"}});var c={_frontmatter:o},l=r.a;function p(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,r={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,["components"]);return Object(a.b)(l,s({},c,n,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"quick-start"},"Quick Start"),Object(a.b)("h2",{id:"path-selector"},"Path Selector"),Object(a.b)("p",null,"Suppose you have such a normalized state:"),Object(a.b)("pre",null,Object(a.b)("code",s({parentName:"pre"},{className:"language-js"}),"const state = {\n  persons: {\n    1: {\n      id: 1,\n      firstName: 'Marry',\n      secondName: 'Poppins',\n    },\n    2: {\n      id: 2,\n      firstName: 'Harry',\n      secondName: 'Potter',\n    },\n  },\n};\n")),Object(a.b)("p",null,"And you want to build something like this selector:"),Object(a.b)("pre",null,Object(a.b)("code",s({parentName:"pre"},{className:"language-js"}),"const personFullNameSelector = createSelector(\n  (state, props) => state.persons[props.personId].firstName,\n  (state, props) => state.persons[props.personId].secondName,\n  (firstName, secondName) => `${firstName} ${secondName}`,\n);\n")),Object(a.b)("p",null,"As you can see in the dependencies of this selector quite a lot of boilerplate code. The problem of duplicate code can be solved with ",Object(a.b)("inlineCode",{parentName:"p"},"createPathSelector"),":"),Object(a.b)("pre",null,Object(a.b)("code",s({parentName:"pre"},{className:"language-js"}),"import { createPathSelector } from 'reselect-utils';\n\nconst personSelector = (state, props) => state.persons[props.personId];\n\nconst personFullNameSelector = createSelector(\n  createPathSelector(personSelector).firstName(),\n  createPathSelector(personSelector).secondName(),\n  (firstName, secondName) => `${firstName} ${secondName}`,\n);\n")),Object(a.b)("p",null,"You can also add default values if you want the selector to produce an adequate result even in the absence of the necessary ",Object(a.b)("inlineCode",{parentName:"p"},"person")," in the ",Object(a.b)("inlineCode",{parentName:"p"},"state"),":"),Object(a.b)("pre",null,Object(a.b)("code",s({parentName:"pre"},{className:"language-js"}),"import { createPathSelector } from 'reselect-utils';\n\nconst personFullNameSelector = createSelector(\n  createPathSelector(personSelector).firstName('John'),\n  createPathSelector(personSelector).secondName('Doe'),\n  (firstName, secondName) => `${firstName} ${secondName}`,\n);\n")),Object(a.b)("p",null,"There are short aliases for many helpers in this library, so you can re-write your code like this:"),Object(a.b)("pre",null,Object(a.b)("code",s({parentName:"pre"},{className:"language-js"}),"import { path } from 'reselect-utils';\n\nconst personFullNameSelector = createSelector(\n  path(personSelector).firstName('John'),\n  path(personSelector).secondName('Doe'),\n  (firstName, secondName) => `${firstName} ${secondName}`,\n);\n")),Object(a.b)("p",null,"You can also work with objects of unlimited nesting:"),Object(a.b)("pre",null,Object(a.b)("code",s({parentName:"pre"},{className:"language-js"}),"import { path } from 'reselect-utils';\n\nconst personSelectorInfo = createSelector(\n  path(personSelector).address.street('-'),\n  path(personSelector).some.very.deep.field(123),\n  (street, field) => ({ street, field }),\n);\n")),Object(a.b)("p",null,"A more detailed description can be found ",Object(a.b)("a",s({parentName:"p"},{href:"/reselect-utils/docz/reference/guides/path-and-prop-selectors"}),"here"),"."),Object(a.b)("h2",{id:"chain-selector"},"Chain Selector"),Object(a.b)("p",null,"Suppose you have such a normalized state:"),Object(a.b)("pre",null,Object(a.b)("code",s({parentName:"pre"},{className:"language-js"}),"const state = {\n  persons: {\n    1: {\n      id: 1,\n      firstName: 'Marry',\n      secondName: 'Poppins',\n    },\n    2: {\n      id: 2,\n      firstName: 'Harry',\n      secondName: 'Potter',\n    },\n  },\n\n  messages: {\n    100: {\n      id: 100,\n      personId: 1,\n      text: 'Hello',\n    },\n    200: {\n      id: 200,\n      personId: 2,\n      text: 'Buy',\n    },\n  },\n};\n")),Object(a.b)("p",null,"And you want to select a person by the message id. You can write something like this:"),Object(a.b)("pre",null,Object(a.b)("code",s({parentName:"pre"},{className:"language-js"}),"const personSelectorByMessageId = (state, props) => {\n  const message = state.messages[props.messageId];\n\n  return state.persons[message.personId];\n};\n")),Object(a.b)("p",null,"This is an acceptable solution, but what if the chain is longer? ",Object(a.b)("inlineCode",{parentName:"p"},"Chain Selector")," will help to solve such problems:"),Object(a.b)("pre",null,Object(a.b)("code",s({parentName:"pre"},{className:"language-js"}),"import { chain, bound } from 'reselect-utils';\n\nconst messageSelector = (state, props) => state.messages[props.messageId];\nconst personSelector = (state, props) => state.persons[props.personId];\n\nconst personByMessageIdSelector = chain(messageSelector)\n  .chain(message => bound(personSelector, { personId: message.personId }))\n  .build();\n")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"Chain Selector")," allows you to create dynamic selectors that depend on the current state. Moreover, the callback that is passed to the ",Object(a.b)("inlineCode",{parentName:"p"},"chain")," method is cached by input parameters. ",Object(a.b)("inlineCode",{parentName:"p"},"bound")," binds the selector to specific parameter values and turns a parametric selector into an non parametric. And at the end you must call the ",Object(a.b)("inlineCode",{parentName:"p"},"build")," method to get the normal selector. Itâ€™s like a chain of ",Object(a.b)("a",s({parentName:"p"},{href:"https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Promise"}),"Promises"),". ",Object(a.b)("a",s({parentName:"p"},{href:"/reselect-utils/docz/reference/guides/chain-selector"}),"Chain Selector")," and ",Object(a.b)("a",s({parentName:"p"},{href:"/reselect-utils/docz/reference/guides/bound-and-adapted-selectors"}),"Bound Selector")," are described in detail in Guides section."))}p&&p===Object(p)&&Object.isExtensible(p)&&!p.hasOwnProperty("__filemeta")&&Object.defineProperty(p,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"docs/quick-start.md"}}),p.isMDXComponent=!0}}]);
//# sourceMappingURL=component---docs-quick-start-md-25959fd5eabc46462ad2.js.map