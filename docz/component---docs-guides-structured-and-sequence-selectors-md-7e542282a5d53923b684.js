(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{Had6:function(e,t,r){"use strict";r.r(t),r.d(t,"_frontmatter",(function(){return c})),r.d(t,"default",(function(){return l}));r("1c7q"),r("abGl"),r("gZHo"),r("Fdmb"),r("Ir+3"),r("2mQt");var s=r("/FXl"),n=r("TjRS");r("aD51");function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var s in r)Object.prototype.hasOwnProperty.call(r,s)&&(e[s]=r[s])}return e}).apply(this,arguments)}var c={};void 0!==c&&c&&c===Object(c)&&Object.isExtensible(c)&&!c.hasOwnProperty("__filemeta")&&Object.defineProperty(c,"__filemeta",{configurable:!0,value:{name:"_frontmatter",filename:"docs/guides/structured-and-sequence-selectors.md"}});var a={_frontmatter:c},p=n.a;function l(e){var t=e.components,r=function(e,t){if(null==e)return{};var r,s,n={},o=Object.keys(e);for(s=0;s<o.length;s++)r=o[s],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,["components"]);return Object(s.b)(p,o({},a,r,{components:t,mdxType:"MDXLayout"}),Object(s.b)("h1",{id:"structured--sequence-selectors"},"Structured & Sequence Selectors"),Object(s.b)("p",null,"If you ever used ",Object(s.b)("a",o({parentName:"p"},{href:"https://github.com/reduxjs/reselect"}),"Reselect"),", you must be familiar with ",Object(s.b)("a",o({parentName:"p"},{href:"https://github.com/reduxjs/reselect#createstructuredselectorinputselectors-selectorcreator--createselector"}),"Structured Selector"),". Reselect Utils provides implementation of this helper but with improved typings. You can use ",Object(s.b)("inlineCode",{parentName:"p"},"Structured Selector")," from this library with heterogeneous selectors. Heterogeneous selectors are selectors with different types of state. See example:"),Object(s.b)("pre",null,Object(s.b)("code",o({parentName:"pre"},{className:"language-typescript"}),"type PersonsStateSlice = {\n  persons: Record<number, Person>;\n};\n\nconst personsSelector = (state: PersonsStateSlice) => state.persons;\n\ntype MessagesStateSlice = {\n  messages: Record<number, Message>;\n};\n\nconst messagesSelector = (state: MessagesStateSlice) => state.messages;\n")),Object(s.b)("p",null,"Now we can write selector what select data from both state slices:"),Object(s.b)("pre",null,Object(s.b)("code",o({parentName:"pre"},{className:"language-typescript"}),"import { createStructuredSelector } from 'reselect-utils';\n\nconst personsAndMessagesSelector = createStructuredSelector({\n  persons: personsSelector,\n  messages: messagesSelector,\n});\n")),Object(s.b)("p",null,"You can also use alias to reduce code:"),Object(s.b)("pre",null,Object(s.b)("code",o({parentName:"pre"},{className:"language-typescript"}),"import { struct } from 'reselect-utils';\n\nconst personsAndMessagesSelector = struct({\n  persons: personsSelector,\n  messages: messagesSelector,\n});\n")),Object(s.b)("p",null,"If you use parametric selector, you can use ",Object(s.b)("a",o({parentName:"p"},{href:"https://github.com/toomuchdesign/re-reselect"}),"Re-reselect"),". Reselect Utils provides ",Object(s.b)("inlineCode",{parentName:"p"},"Cached Structured Selector")," for these proposes. For example, we have next selectors:"),Object(s.b)("pre",null,Object(s.b)("code",o({parentName:"pre"},{className:"language-typescript"}),"import createCachedSelector from 're-reselect';\n\nconst personSelector = createCachedSelector(\n  personsSelector,\n  (state: PersonsStateSlice, props: Props) => props.personId,\n  (persons, personId) => persons[personId],\n)({\n  keySelector: (state, props) => props.personId,\n});\n\nconst messageSelector = createCachedSelector(\n  messagesSelector,\n  (state: MessagesStateSlice, props: Props) => props.messageId,\n  (messages, messageId) => messages[messageId],\n)({\n  keySelector: (state, props) => props.messageId,\n});\n")),Object(s.b)("p",null,"You can write composing selector this way:"),Object(s.b)("pre",null,Object(s.b)("code",o({parentName:"pre"},{className:"language-typescript"}),"import { cachedStruct } from 'reselect-utils';\n\nconst personAndMessageSelector = cachedStruct({\n  persons: personSelector,\n  messages: messageSelector,\n})({ keySelector: (state, props) => `${props.personId}:${props.messageId}` });\n")),Object(s.b)("p",null,"There is also another type of structure besides objects - arrays. Reselect Utils provides ",Object(s.b)("inlineCode",{parentName:"p"},"Sequence Selector")," helper for them:"),Object(s.b)("pre",null,Object(s.b)("code",o({parentName:"pre"},{className:"language-typescript"}),"import createCachedSelector from 're-reselect';\nimport { bound, createSequenceSelector } from 'reselect-utils';\n\nconst personSelector = createCachedSelector(\n  personsSelector,\n  (state: PersonsStateSlice, props: Props) => props.personId,\n  (persons, personId) => persons[personId],\n)({\n  keySelector: (state, props) => props.personId,\n});\n\nconst firstPersonSelector = bound(personSelector, { personId: 1 });\nconst secondPersonSelector = bound(personSelector, { personId: 2 });\n\nconst firstTwoPersonsSelector = createSequenceSelector([\n  firstPersonSelector,\n  secondPersonSelector,\n]);\n")),Object(s.b)("p",null,"Now if you have next state, you will receive next result:"),Object(s.b)("pre",null,Object(s.b)("code",o({parentName:"pre"},{className:"language-typescript"}),"const state = {\n  persons: {\n    1: {\n      id: 1,\n      firstName: 'Marry',\n      secondName: 'Poppins',\n    },\n    2: {\n      id: 2,\n      firstName: 'Harry',\n      secondName: 'Potter',\n    },\n  },\n};\n\nfirstTwoPersonsSelector(state); // => [{ firstName: 'Marry', ... }, { firstName: 'Harry', ... }]\n")),Object(s.b)("p",null,"If you try to combine parametric selectors, there is cached version of this helper:"),Object(s.b)("pre",null,Object(s.b)("code",o({parentName:"pre"},{className:"language-typescript"}),"import { path, prop, bound, cachedSeq } from 'reselect-utils';\n\ntype Props = {\n  personId: number;\n  postfix: string;\n};\n\nconst personFullNameSelector = createCachedSelector(\n  path(personSelector).firstName(),\n  path(personSelector).secondName(),\n  prop<Props>().postfix(),\n  (firstName, secondName, postfix) => `${firstName} ${secondName} (${postfix})`,\n)({\n  keySelector: (state, props) => `${props.personId}:${props.postfix}`,\n});\n\nconst firstPersonFullNameSelector = bound(personFullNameSelector, {\n  personId: 1,\n});\nconst secondPersonFullNameSelector = bound(personFullNameSelector, {\n  personId: 2,\n});\n\nconst firstTwoPersonFullNamesSelector = cachedSeq([\n  firstPersonFullNameSelector,\n  secondPersonFullNameSelector,\n])({\n  keySelector: prop<Props>().postfix(),\n});\n\nfirstTwoPersonsSelector(state, { postfix: '*' }); // => ['Marry Poppins (*)', 'Harry Potter (*)' }]\n\nfirstTwoPersonsSelector(state, { postfix: '?' }); // => ['Marry Poppins (?)', 'Harry Potter (?)' }]\n")))}l&&l===Object(l)&&Object.isExtensible(l)&&!l.hasOwnProperty("__filemeta")&&Object.defineProperty(l,"__filemeta",{configurable:!0,value:{name:"MDXContent",filename:"docs/guides/structured-and-sequence-selectors.md"}}),l.isMDXComponent=!0}}]);
//# sourceMappingURL=component---docs-guides-structured-and-sequence-selectors-md-7e542282a5d53923b684.js.map